---
title: "Practical 3"
author: "James Hollway"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Practical 3}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Calculating different centrality measures

For this exercise, we'll use the `ison_brandes` dataset.
This dataset is in a 'tidygraph' format, 
but migraph makes it easy to coerce this into other forms
to be compatible with other packages.

```{r coercion}
library(migraph)
(mat <- as_matrix(ison_brandes))
autographr(ison_brandes)
```

Let's start with calculating degree, as it is easy to calculate yourself.
Just sum the rows or columns of the matrix!

```{r degreesum}
(degrees <- rowSums(mat))
rowSums(mat) == colSums(mat)
# Are they all equal? Why?
# You can also just use a built in command in migraph though:
node_degree(ison_brandes, normalized = FALSE)
```

Often we are interested in the distribution of (degree) centrality in a network.
`{migraph}` offers a way to get a pretty good first look at this distribution,
though there are more elaborate ways to do this in base and grid graphics.

```{r distrib}
plot(node_degree(ison_brandes), "h") +
  plot(node_degree(ison_brandes), "d")
```

Other measures of centrality can be a little trickier to calculate by hand.
Fortunately, we can use functions from migraph to help:

```{r micent}
node_betweenness(ison_brandes)
node_closeness(ison_brandes)
node_eigenvector(ison_brandes)
# TASK: Can you create degree distributions for each of these?
```

Note that all centrality measures in `{migraph}` return normalized
scores by default -- 
for the raw scores, just add `normalized = FALSE` as an extra argument.

There are an enormous number of centrality measures available
in R across a range of packages.
In addition to the main four used here, `{igraph}` includes:

```
graph.strength()
alpha_centrality()
power_centrality()
page_rank()
eccentricity()
hub_score()
authority_score()
subgraph_centrality()
```

`{sna}` implements most of these too, plus a few extra:

```
flowbet()
loadcent()
gilschmidt()
infocent()
stresscent()
```

There are also some dedicated centrality packages,
such as [centiserve](https://www.centiserver.org/),
`{CINNA}`, `{influenceR}`, and `{keyplayer}`.
There are also pretty exhaustive [discussions of this online](https://www.r-bloggers.com/2018/12/network-centrality-in-r-an-introduction/).

# Plotting different centrality measures

There is also a function in `{migraph}` that plots our network 
and highlights the node with the maximum (e.g. degree) score.
We can choose which measure to highlight,
and even which node to identify in red as the maximum (by default),
minimum, or some other function to single out a node.

```{r ggid}
autographr(ison_brandes, highlight_measure = "node_degree") +
autographr(ison_brandes, highlight_measure = "node_betweenness")
autographr(ison_brandes, highlight_measure = "node_closeness") +
autographr(ison_brandes, highlight_measure = "node_eigenvector")
```

How neat!

# Calculating centralization

`{migraph}` also implements centralization functions.
Here we are no longer interested in the level of the node,
but in the level of the whole graph, so the syntax is:

```{r centzn}
graph_degree(ison_brandes)
graph_betweenness(ison_brandes)
graph_closeness(ison_brandes)
graph_eigenvector(ison_brandes)
graph_degree(ison_southern_women)
graph_betweenness(ison_southern_women)
graph_closeness(ison_southern_women)
graph_eigenvector(ison_southern_women)
```

By default, scores are printed to 3 decimal places,
but this can be modified and, in any case, 
the unrounded values are retained internally and passed on.

Note that for centralization in two-mode networks,
two values are given (as a named vector),
since normalization typically depends on the (asymmetric)
number of nodes in each mode.

# Exporting plots to PDF

We can print the plots we have made to PDF by point-and-click
by selecting 'Save as PDF...' from under the 'Export' dropdown menu
in the plots panel tab of RStudio.

If you want to do this programmatically,
say because you want to record how you have saved it so that you can
e.g. make some changes to the parameters at some point,
this is also not too difficult.

After running the (gg-based) plot you want to save,
use the command `ggsave("my_filename.pdf")` to save your plot
as a PDF to your working directory.
If you want to save it somewhere else, you will need to specify the file path
(or change the working directory, but that might be more cumbersome).
If you want to save it as a different filetype,
replace `.pdf` with e.g. `.png` or `.jpeg`.
See `?ggsave` for more.

But what if we want to have a single image/figure with multiple plots?
This can be a little tricky with gg-based plots,
but fortunately the `{patchwork}` package is here to help.

```{r multiplot}
gd <- autographr(ison_brandes, highlight_measure = "node_degree") + 
  ggtitle("Degree", subtitle = round(graph_degree(ison_brandes), 2))
gc <- autographr(ison_brandes, highlight_measure = "node_closeness") + 
  ggtitle("Closeness", subtitle = round(graph_closeness(ison_brandes), 2))
gb <- autographr(ison_brandes, highlight_measure = "node_betweenness") + 
  ggtitle("Betweenness", subtitle = round(graph_betweenness(ison_brandes), 2))
ge <- autographr(ison_brandes, highlight_measure = "node_eigenvector") + 
  ggtitle("Eigenvector", subtitle = round(graph_eigenvector(ison_brandes), 2))
(gd | gb) / (gc | ge)
# ggsave("brandes-centralities.pdf")
```

# Tasks

1. Import the drugnet data from Moodle
(Since it is an RData file, you can just load it).
`load("drugnet.RData")`

2. Name a plausible research question you could ask of this data
for each of the four main centrality measures
(degree, betweenness, closeness, eigenvector)
You may want to add these as titles or subtitles to each plot.

3. How centralized is the network?
