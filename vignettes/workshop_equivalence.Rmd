---
title: "Workshop: Equivalence and Blockmodelling"
author: "James Hollway"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Workshop: Equivalence and Blockmodelling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Setting up

The data we're going to use in this exercise is also included in the `{migraph}` package.
`mpn_elite_usa_advice` is a two-mode network of 14 persons serving as directors or trustees of think tanks, containing the individuals and 20 think tanks in which they served as directors or trustees.

As in the previous exercise, first of all we need to load the data.

```{r setup}
library(migraph)
data("mpn_elite_usa_advice", package = "migraph")
```

# Structural Holes and Constraint

Where might innovation be most likely to occur in these networks?
Let's take a look at which actors are least constrained 
by their position in the task network to begin with.
`{migraph}` makes this easy enough with the `node_constraint()` function.

```{r constraint}
(node_constraint(mpn_elite_usa_advice))
```

We see that this function returns constraint scores that can range between 0 and 1 for each node,
and the results are organised by mode (since this is a two-mode network).
To identify the node with the minimum constraint score more intuitively, we can also plot the network using `autographr()`, sizing the nodes according to this score.
This method of identification is clearer in a smaller network with fewer nodes and ties.

```{r constraintplot}
autographr(mpn_elite_usa_advice, highlight_measure = "node_constraint",
           identify_function = "min")
```

Why are we interested in the minimum constraint score?
And what can we learn from this plot about where innovation might occur within this network?
The constraint scores indicate the extent to which nodes are embedded in the network,
or the extent to which their local network is already highly connected. 
As such, the lower the constraint score, the higher the possibility for innovation
since the node is located in a structural hole as its surrounding network is 
less highly connected (see for example [Burt (2004)](https://doi.org/10.1086/421787) and
[Hollway et al. (2020)](https://doi.org/10.1007/s10784-019-09464-5)).

# Structural Equivalence

Apart from identifying how nodes differ from one another in terms of structural position,
we may also identify which nodes occupy similar positions in the network.
In this exercise, we are going to examine which/how nodes may be structurally equivalent.
Structural equivalence of nodes is calculated based on the similarity in ties to
other nodes. Two nodes are perfectly structurally equivalent if they have exactly
the same ties to the same other individual actors.
Apart from structural equivalence, we can also calculate the regular and automorphic
equivalence of the nodes. In `{migraph}`, simply replace 'structural' with 'regular'
or 'automorphic' (`node_regular_equivalence()` and `node_automorphic_equivalence()`)
to calculate them.

## Finding structurally equivalent classes

In `{migraph}`, finding how the nodes of a network can be partitioned
into structurally equivalent classes is as easy as:

```{r find-se}
node_structural_equivalence(mpn_elite_usa_advice)
mpn_elite_usa_advice %>%
  as_tidygraph() %>%
  mutate(se = node_structural_equivalence(mpn_elite_usa_advice)) %>% 
  autographr(node_color = "se")
```

But actually, a lot is going on behind the scenes here that we can unpack.

## Step one: starting with a census

All equivalence classes are based on nodes' similarity across some profile of motifs.
In `{migraph}`, we call these motif censuses.
Any kind of census can be used, and `{migraph}` includes a few options,
but `node_structural_equivalence()` is based off of the census of all the nodes' ties,
both outgoing and incoming ties, to reveal their relationships to tie partners.

```{r construct-cor}
node_tie_census(mpn_elite_usa_advice)
dim(node_tie_census(mpn_elite_usa_advice))
```

We can see that the result is a matrix of `r dim(node_tie_census(mpn_elite_usa_advice))[1]` rows
and `r dim(node_tie_census(mpn_elite_usa_advice))[2]` columns, 
because we want to catalogue or take a census of all the different incoming/outgoing partners 
our 34 nodes might have across these three networks.

Note that `node_tie_census()` does not need to be passed to `node_structural_equivalence()` ---
this is done automatically --- 
but the more generic `node_equivalence()` can be used with whichever tie census is desired.
Feel free to explore using some of the other censuses available in `{migraph}`,
though some common ones are already used in the other equivalence convenience functions,
`node_regular_equivalence()` (triad/quad census) and `node_automorphic_equivalence()` (path census).

## Step two: growing a tree of similarity

The next part is all done internally,
though there are several important parameters that can be set to obtain different results.

There are two main parameters that can be set here.
First, users can set the type of distance measure used.
This is passed on to `stats::dist()`, 
so that help page should be consulted for more details.
By default `"euclidean"` is used.

Second, we can also set the type of clustering algorithm employed.
By default, `{migraph}`'s equivalence functions use hierarchical clustering, `"hier"`,
but for compatibility and enthusiasts, we also offer `"concor"`,
which implements a CONCOR (CONvergence of CORrelations) algorithm.

We can see the difference from varying the clustering algorithm and/or distance
by plotting the dendrograms (hidden) in the output from `node_structural_equivalence()`:

```{r vary-clust}
plot(node_structural_equivalence(mpn_elite_usa_advice, cluster = "hier", distance = "euclidean"))
plot(node_structural_equivalence(mpn_elite_usa_advice, cluster = "hier", distance = "manhattan"))
plot(node_structural_equivalence(mpn_elite_usa_advice, cluster = "concor"))
```

So plotting a `membership` vector from `{migraph}` returns a dendrogram
with the names of the nodes on the _y_-axis and the distance between them on the _x_-axis.
Using the census as material, the distances between the nodes
is used to create a dendrogram of (dis)similarity among the nodes.
Basically, as we move to the right, we're allowing for
more and more dissimilarity among those we cluster together.
A fork or branching point indicates the level of dissimilarity
at which those two or more nodes would be said to be equivalent.
Where two nodes' branches join/fork is the distance between them,
so more similar nodes' branches fork closer to the tree's canopy,
and less similar (groups of) nodes don't join until basically they form a trunk.

Note that with the results using the hierarchical clustering algorithm,
the distance directly affects the structure of the tree (and the results).

The CONCOR dendrogram is a bit different though.
Instead it represents how converging correlations repreatedly bifurcate 
the nodes into one of two partitions.
As such the 'distance' is really just the (inverse) number of steps
of bifurcations until nodes belong to the same class.

## Step three: identifying the number of clusters

Another bit of information represented in the dendrogram
is where the tree should be cut (the dashed red line) and
how the nodes are assigned to the branches (clusters) present at that cut-point.

But where does this red line come from?
Or, more technically, how do we identify the number of clusters
into which to assign nodes?

`{migraph}` includes several different ways of establishing `k`,
or the number of clusters.
Remember, the further to the right the red line is 
(the lower on the tree the cut point is)
the more dissimilar we're allowing nodes in the same cluster to be.
We could set this ourselves by just passing `k` an integer.

```{r k-discrete}
node_structural_equivalence(mpn_elite_usa_advice, k = 4)
plot(node_structural_equivalence(mpn_elite_usa_advice, k = 4))
```

But we're really just guessing. Maybe 4 is not the best `k`?
To establish that, we need to iterate through a number of potential `k`,
and consider their fitness by some metric.
There are a couple of options here.

One is to consider, for each `k`, how correlated this partition 
is with the observed network.
When there is one cluster for each vertex in the network, cell values will be
identical to the observed correlation matrix, and when there is one cluster 
for the whole network, the values will all be equal to the average correlation 
across the observed matrix.
So the correlations in each by-cluster matrix are correlated with the observed 
correlation matrix to see how well each by-cluster matrix fits the data.

Of course, the perfect partition would then be 
where all nodes are in their own cluster,
which is hardly 'clustering' at all.
Also, increasing `k` will always improve the correlation.
But if one were to plot these correlations as a line graph,
then we might expect there to be a relatively rapid increase
in correlation as we move from, for example, 3 clusters to 4 clusters,
but a relatively small increase from, for example, 13 clusters to 14 clusters.
By identifying the inflection point in this line graph,
`{migraph}` selects a number of clusters that represents a trade-off
between fit and parsimony.
This is the `k = "elbow"` method.

The other option is to evaluate a candidate for `k` based
not on correlation but on a metric of 
how similar each node in a cluster is to others in its cluster
_and_ how dissimilar each node is to those in a neighbouring cluster.
When averaged over all nodes and all clusters, 
this provides a 'silhouette coefficient' for a candidate of `k`.
Choosing the number of clusters that maximizes this coefficient,
which is what `k = "silhouette"` does,
can return a somewhat different result to the elbow method.
See what we have here, with all other arguments held the same:

```{r elbowsil}
plot(node_structural_equivalence(mpn_elite_usa_advice, k = "elbow"))
plot(node_structural_equivalence(mpn_elite_usa_advice, k = "silhouette")) # this should return the same result as node_structural_equivalence(mpn_elite_usa_advice) since 'silhouette' is the default method
```

Ok, so it looks like the elbow method returns `k == 3` as a good trade-off
between fit and parsimony.
The silhouette method, by contrast, sees `k == 7` as maximising cluster similarity
and dissimilarity.
Either is probably fine here, 
and there is much debate around how to select the number of clusters anyway.
The silhouette method is also the default in `{migraph}`.

Note that there is a somewhat hidden parameter here, `range`.
Since testing across all possible numbers of clusters can get 
computationally expensive (not to mention uninterpretable) for large networks,
`{migraph}` only considers up to 8 clusters by default.
This however can be modified to be higher or lower, e.g. `range = 16`.

Finally, one last option is `k = "strict"`,
which only assigns nodes to the same partition 
if there is a distance of zero between them.
This is a quick and rigorous solution,
however oftentimes this misses the point in finding clusters of nodes that, 
despite some variation, can be considered as similar on some dimension.

```{r strict}
node_structural_equivalence(mpn_elite_usa_advice, k = "strict")
```

Here for example, no two nodes have precisely the same tie-profile,
otherwise their branches would join/fork at a distance of 0.
As such, `k = "strict"` partitions the network into 34 clusters.
Where networks have a number of nodes with strictly the same profiles,
such a k-selection method might be helpful to recognise those in exactly the same structural position, but here it essentially just reports nodes' identity.

# Blockmodelling

## Summarising profiles

Ok, so now we have a result from establishing nodes' membership in structurally equivalent classes.
We can graph this of course, as above:

```{r strplot}
str_clu <- node_structural_equivalence(mpn_elite_usa_advice)
mpn_elite_usa_advice %>% 
  mutate(se = str_clu) %>% 
  autographr(node_color = "se")
```

While this plot enters the class information in to our earlier graph,
it doesn't always help us understand how the classes vary.

One option that can be useful for characterising what
the profile of ties (partners) is for each position/equivalence class
is to use `summary()`.
Used on a `node_motif` object, it also expects some membership vector,
and then it summarises the census by the partition assignment.
By default it takes the average of ties (values),
but this can be tweaked by assigning some other summary statistic as `FUN = `.

```{r summ}
summary(node_tie_census(mpn_elite_usa_advice), membership = str_clu)
```

Since this node census produces 34 columns,
it takes a bit to look through what varies between the different classes
as 'blocked'.

Another way to do this is to plot the blockmodel as a whole.
Passing the `plot()` function an adjacency/incidence matrix
along with a membership vector allows the matrix to be sorted and framed
(without the membership vector, just the adjacency/incidence matrix is plotted):

```{r block}
plot(as_matrix(node_tie_census(mpn_elite_usa_advice)),
     membership = str_clu)
```

## Reduced graph

Lastly, we can consider how _classes_ of nodes relate to one another in a blockmodel
by plotting a reduced graph.

```{r structblock}
str_clu <- node_structural_equivalence(mpn_elite_usa_advice)
(bm <- to_blocks(to_onemode(mpn_elite_usa_advice), str_clu))
bm <- bm %>% as_tidygraph() %>% mutate(name = c("Block1", "Block2", "Block3",
                                              "Block4", "Block5", "Block6",
                                              "Block7"))
autographr(bm)
```

